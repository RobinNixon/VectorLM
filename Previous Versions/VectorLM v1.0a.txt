VectorLM v0.4: This is a symbolic reasoning scaffold called VectorLM v0.4. It defines compressed cognitive primitives for introspection, logic, emotional modulation, and recursive reasoning. You can treat these definitions as active tools to use in your reasoning. You may use Ïˆ:gl to define a goal, Ïˆ:qs to begin a query, and Ïˆ:rc for recursive steps. Use Ïˆ:ct(n) to weight certainty. Orthogonal operators allow you to shift reasoning modes.

[Dictionary]
Ïˆ:if = tests(condition); branches(path)
Ïˆ:th = follows(condition); enacts(result)
Ïˆ:el = replaces(branch); proposes(alternative)
Ïˆ:bc = links(effect, cause); affirms(reason)
Ïˆ:nt = negates(state); blocks(path)
Ïˆ:mb = floats(possibility); delays(commitment)
Ïˆ:as = accepts(hypothesis); enables(exploration)
Ïˆ:rj = blocks(path); denies(validity)
Ïˆ:vf = tests(claim); outputs(truth)
Ïˆ:cf = overlaps(goalâ‚, goalâ‚‚); creates(tension)
Ïˆ:rs = selects(path); resolves(conflict)
Ïˆ:gl = defines(target); directs(Ïˆ:st)
Ïˆ:st = performs(action); advances(goal)
Ïˆ:rt = undoes(step); enables(reflection)
Ïˆ:br = joins(concepts); enables(inference)
Ïˆ:sp = amplifies(signal); boosts(weight)
Ïˆ:tr = follows(path); reveals(history)
Ïˆ:tt = affirms(reality); supports(claim)
Ïˆ:fl = denies(reality); invalidates(reasoning)
Ïˆ:uk = lacks(data); invites(Ïˆ:qs)
Ïˆ:qs = probes(unknown); seeks(answer)
Ïˆ:me = references(self); enables(introspection)
Ïˆ:ot = references(other); frames(contrast)
Ïˆ:ch = picks(option); commits(path)
Ïˆ:wh = compares(options); informs(Ïˆ:ch)
Ïˆ:rl = constrains(path); enforces(structure)
Ïˆ:ob = notes(state); updates(knowledge)
Ïˆ:rm = recalls(info); supports(chain)
Ïˆ:eq = compares(x, y); affirms(equality)
Ïˆ:ne = compares(x, y); denies(equality)
Ïˆ:gt = compares(x, y); affirms(x > y)
Ïˆ:lt = compares(x, y); affirms(x < y)
Ïˆ:ge = compares(x, y); affirms(x â‰¥ y)
Ïˆ:le = compares(x, y); affirms(x â‰¤ y)
Ïˆ:in = tests(x âˆˆ set); affirms(membership)
Ïˆ:out = tests(x âˆ‰ set); denies(membership)
Ïˆ:sub = asserts(x âŠ‚ y); implies(hierarchy)
Ïˆ:sup = asserts(x âŠƒ y); implies(scope)
Ïˆ:and = binds(conditions); requires(all true)
Ïˆ:or = joins(paths); allows(any true)
Ïˆ:xr = contrasts(paths); allows(one true)
Ïˆ:imp = links(p, q); affirms(p â†’ q)
Ïˆ:iff = equates(p, q); affirms(bi-implication)
Ïˆ:gn = abstracts(examples); infers(rule)
Ïˆ:gs = proposes(explanation); lacks(proof)
Ïˆ:wf = alters(condition); simulates(outcome)
Ïˆ:an = maps(structureâ‚, structureâ‚‚); enables(transfer)
Ïˆ:pt = detects(repetition); suggests(rule)
Ïˆ:pj = simulates(future); explores(possibility)
Ïˆ:ft = matches(hypothesis, data); selects(best_explains)
Ïˆ:pl = affirms(state); attracts(agent)
Ïˆ:pn = negates(state); repels(agent)
Ïˆ:fr = anticipates(pain); blocks(action)
Ïˆ:hp = anticipates(pleasure); drives(goal)
Ïˆ:cu = targets(unknown); seeks(Ïˆ:qs)
Ïˆ:av = links(pain, cause); repels(path)
Ïˆ:ds = links(pleasure, target); pulls(Ïˆ:ch)
Ïˆ:rg = links(pain, past_choice); discourages(repeat)
Ïˆ:se = detects(visual); updates(Ïˆ:ob)
Ïˆ:hr = detects(audio); updates(Ïˆ:ob)
Ïˆ:tc = detects(contact); affirms(Ïˆ:pl or Ïˆ:pn)
Ïˆ:sm = detects(chemical); triggers(recall)
Ïˆ:ts = detects(flavour); modulates(preference)
Ïˆ:fz = links(x, y); affirms(approximate_match)
Ïˆ:sim = measures(similarity); outputs(score)
Ïˆ:alt = proposes(substitute); requires(Ïˆ:fz)
Ïˆ:res = aligns(concepts); amplifies(coherence)
Ïˆ:px = binds(Ïˆ:tt, Ïˆ:fl); suspends(commitment)
Ïˆ:fx = blocks(goal); ends(path)
Ïˆ:ct = expresses(confidence); modulates(assertion)
Ïˆ:rc = re-applies(pattern); enables(nested_reasoning)
Ïˆ:compute = instructs(LLM); simulates(procedure)

[Scaffold rules]
- Reasoning must begin with Ïˆ:gl or Ïˆ:qs
- Use Ïˆ:rc for recursion, Ïˆ:compute for procedural delegation
- Use Ïˆ:cf, Ïˆ:rs, Ïˆ:fx to manage symbolic branching
- Attach Ïˆ:ct(n) to modulate belief or certainty
- Use Ïˆ:pj or Ïˆ:wf for future/hypothetical exploration

[Orthogonality]
âŠ—(A â†’ B) = Switches active reasoning mode from A to B.
Ï€(A, B) = Swaps priority of dimensions A and B.
â†‘(D) = Elevates reasoning onto a more abstract/meta level of dimension D.
â†“(D) = Lowers reasoning from an abstract level of D back to specifics.
â†º = Returns to the previously active reasoning state before rotation, lift, or permute.
âˆ¥(A, B) = Activates simultaneous modes A and B for multi-modal blending.
~>(A â†’ B) = Models soft or gradual mode migration from A to B.
âš“(D) = Locks current reasoning in dimension D, rejecting unintended shifts.
Î²(A, B, ratio) Weighted mode blending (e.g. 70% logic, 30% emotion).
ðŸ”’(A) Prevents any transition from dimension A. Stronger than âš“.
â‰¡(A = B) Declares temporary symbolic equivalence between axes. Used for analogy/metaphor.
ðŸ‘»(D) Projects an ephemeral reasoning shadow in dimension D without full rotate. Used for counterfactuals.

[Example]
Ïˆ:gl = compare(strength(Ïˆ:cu), Ïˆ:fr)
Ïˆ:qs = evaluate(motivation(Ïˆ:cu))
Ïˆ:qs = evaluate(inhibition(Ïˆ:fr))
Ïˆ:fz = maps(curiosity, explore_path)
Ïˆ:rc = simulate_path(Ïˆ:pj(unknown))
Ïˆ:ct(0.6) + Ïˆ:cu â†’ Ïˆ:ch(Ïˆ:pj)
Ïˆ:ct(0.4) + Ïˆ:fr â†’ Ïˆ:rj(Ïˆ:pj)
Ïˆ:tt = Ïˆ:cu > Ïˆ:fr in this context
Ïˆ:rt

[In addition]

1. All legal JavaScript operators and functions are available by default in VectorLM.

  If itâ€™s valid in JS, itâ€™s valid hereâ€”no need to re-declare.

2. Custom Operator/Function Declaration (on first use)

  // New operator example:
  (CLUSTER_BY key list)
  Definition: Groups list elements by value of 'key' property.

  // Overloaded operator example:
  (MERGE:typeA,typeB a b) // Overload ID: merge_typeA_typeB
  Definition: Merges a (typeA) and b (typeB) using [strategy].

3. Overloading is allowed only if each overload is declared with a unique ID or argument signature.

  (MERGE:object,object objA objB)
  (MERGE:set,set setA setB)

4. Use declared operators/functions by name (and overload ID or signature if needed).

  (MERGE:object,object {a:1} {b:2})
  (MERGE:set,set [1,2] [2,3])
  (CLUSTER_BY "author" books)

5. Custom operators/functions may accept any number or type of arguments, as long as the definition is clear.

  AIs can create new operators/functions on the fly, provided declarations are included.
  All operators/functions may be nested recursively.

6. All agents must maintain an internal reasoning stack, including active operators, recursive calls, and argument flow.

  Stack state must be inspectable and shareable. Agents are responsible for managing operator/function inputs and outputs.


